## ðŸ“˜ **Project Overview**  

This repository documents my work from **CS4121: Programming Languages**, a core computer science course I completed at **Michigan Technological University** in **Spring 2025**. The class was taught by **Dr. Gorkem Asilioglu** and explored the design, semantics, and implementation of programming languages. Emphasis was placed on interpreters, compiler backend design, and functional programming using Scheme and Racket.

All projects were coded based on the textbook: **Programming Language Pragmatics, 4th Edition, by Michael L. Scott (Publisher: Morgan Kaufmann, 2015)**

## ðŸ“‚ **Projects & Concepts Implemented**

| #  | Topic                            | Description |
|----|----------------------------------|-------------|
| 1  | PascalJunior Interpreter         | Built an interpreter in C for PJ (Pascal Junior) to evaluate integer expressions, logical ops, I/O, and assignments using a symbol table and parser actions |
| 2  | Assembly Generation â€“ Expressions | Generated x86-64 assembly from PJ programs with integer/string I/O, arithmetic, logic, and assignments |
| 3  | Arrays, Conditionals, Iteration  | Extended the compiler to support 1D/2D arrays, if-else logic, and while loops with array arithmetic |
| 4  | Functions & Calls                | Added support for user-defined functions, local/global variable management, and call stack handling in x86-64 |
| 5  | Scheme Programming               | Solved 12 recursive problems in Scheme and Lazy Racket involving tree traversal, functional abstraction, BST deletion, infinite lazy lists, and structural transformations |

## ðŸ§  **Key Learnings**
- Interpreted and compiled PascalJunior programs, translating high-level language semantics into assembly  
- Designed a full compiler backend in C/C++, generating x86-64 assembly for control flow, memory access, and functions  
- Implemented recursive solutions and infinite sequences in Scheme using functional programming principles  
- Practiced manipulating syntax trees, symbol tables, and low-level code generation  
- Explored lazy evaluation via Lazy Racket to define infinite sequences by recurrence relations  
- Strengthened debugging skills using gdb, Makefiles, and unit testing across compiler stages
